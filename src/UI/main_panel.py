from idlelib.tooltip import Hovertip

import numpy
import support
import tkinter as tk
import PIL.Image

from threading import Thread
from tkinter.constants import END
from tkinter import *
from tkinter import messagebox
from tkinter.filedialog import askdirectory
from PIL import ImageTk
from UI import ui_constants
from technique_type import TechniqueType
from model import start_exploiting_gradient
from support import parse_bool


class MainPanel:

    def __init__(self, master):
        support._print_delegate = self
        self.printing_progress = False
        # base data
        self.techniques = ((ui_constants.text_ssd_technique, 0), (ui_constants.text_sod_technique, 1), (ui_constants.text_csd_technique, 2), (ui_constants.text_cod_technique, 3))
        self.technique = TechniqueType.SCORE_SINGLE_DISTANCE
        self.technique_selection = IntVar(0)
        self.base_folder = None
        self.reproducibility = False
        self.use_features = False
        self.resume = False
        # setting UI
        self.root = master
        # setting title
        self.root.title(ui_constants.text_tool_name)
        # setting window size
        width = 900
        height = 570
        screenwidth = self.root.winfo_screenwidth()
        screenheight = self.root.winfo_screenheight()
        align_string = '%dx%d+%d+%d' % (width, height, (screenwidth - width) / 2, (screenheight - height) / 2)
        self.root.geometry(align_string)
        self.root.resizable(width=False, height=False)

        button_select_dataset_folder = tk.Button(self.root)
        button_select_dataset_folder["bg"] = ui_constants.color_bg_button
        button_select_dataset_folder["fg"] = ui_constants.color_fg_button
        button_select_dataset_folder["text"] = ui_constants.text_select_dataset_folder
        button_select_dataset_folder.place(x=340, y=10, width=193, height=30)
        button_select_dataset_folder["command"] = self.select_dataset_folder

        label_quantity_samples_to_select = tk.Label(self.root)
        label_quantity_samples_to_select["justify"] = "left"
        label_quantity_samples_to_select["text"] = ui_constants.text_quantity_samples_to_select + ":"
        label_quantity_samples_to_select.place(x=10, y=80, width=200, height=30)
        Hovertip(label_quantity_samples_to_select, ui_constants.text_description_quantity_samples_to_select)

        self.entry_quantity_samples_to_select = tk.Entry(self.root)
        self.entry_quantity_samples_to_select.insert(0, "500")
        self.entry_quantity_samples_to_select.place(x=220, y=80, width=70, height=30)

        label_limit_samples = tk.Label(self.root)
        label_limit_samples["justify"] = "left"
        label_limit_samples["text"] = ui_constants.text_limit_samples + ":"
        label_limit_samples.place(x=10, y=160, width=200, height=30)
        label_limit_samples.place(x=10, y=120, width=200, height=30)
        Hovertip(label_limit_samples, ui_constants.text_description_limit_samples)

        self.entry_limit_samples = tk.Entry(self.root)
        self.entry_limit_samples.insert(0, "-1")
        self.entry_limit_samples.place(x=220, y=120, width=70, height=30)

        label_resume = tk.Label(self.root)
        label_resume["justify"] = "left"
        label_resume["text"] = ui_constants.text_resume + ":"
        label_resume.place(x=10, y=160, width=200, height=30)
        Hovertip(label_resume, ui_constants.text_description_resume)

        check_resume = tk.Checkbutton(self.root)
        check_resume["offvalue"] = "0"
        check_resume["onvalue"] = "1"
        check_resume["command"] = self.set_resume
        check_resume.place(x=220, y=160, width=70, height=30)

        label_reproducibility = tk.Label(self.root)
        label_reproducibility["justify"] = "left"
        label_reproducibility["text"] = ui_constants.text_reproducibility + ":"
        label_reproducibility.place(x=10, y=200, width=200, height=30)
        Hovertip(label_reproducibility, ui_constants.text_description_reproducibility)

        check_reproducibility = tk.Checkbutton(self.root)
        check_reproducibility["offvalue"] = "0"
        check_reproducibility["onvalue"] = "1"
        check_reproducibility["command"] = self.set_reproducibility
        check_reproducibility.place(x=220, y=200, width=70, height=30)

        label_use_features = tk.Label(self.root)
        label_use_features["justify"] = "left"
        label_use_features["text"] = ui_constants.text_use_features + ":"
        label_use_features.place(x=10, y=240, width=200, height=30)
        Hovertip(label_use_features, ui_constants.text_description_use_features)

        check_use_features = tk.Checkbutton(self.root)
        check_use_features["offvalue"] = "0"
        check_use_features["onvalue"] = "1"
        check_use_features["command"] = self.set_use_features
        check_use_features.place(x=220, y=240, width=70, height=30)

        label_training_epochs = tk.Label(self.root)
        label_training_epochs["justify"] = "left"
        label_training_epochs["text"] = ui_constants.text_training_epochs + ":"
        label_training_epochs.place(x=520, y=80, width=200, height=30)
        Hovertip(label_training_epochs, ui_constants.text_description_training_epochs)

        self.entry_training_epochs = tk.Entry(self.root)
        self.entry_training_epochs.insert(0, "10")
        self.entry_training_epochs.place(x=730, y=80, width=70, height=30)

        label_active_epochs = tk.Label(self.root)
        label_active_epochs["justify"] = "left"
        label_active_epochs["text"] = ui_constants.text_active_epochs + ":"
        label_active_epochs.place(x=520, y=120, width=200, height=30)
        Hovertip(label_active_epochs, ui_constants.text_description_active_epochs)

        self.entry_active_epochs = tk.Entry(self.root)
        self.entry_active_epochs.insert(0, "10")
        self.entry_active_epochs.place(x=730, y=120, width=70, height=30)

        label_technique = tk.Label(self.root)
        label_technique["justify"] = "left"
        label_technique["text"] = ui_constants.text_technique + ":"
        label_technique.place(x=520, y=160, width=200, height=30)
        Hovertip(label_technique, ui_constants.text_description_technique)

        radio_ssd = tk.Radiobutton(self.root)
        radio_ssd["value"] = 0
        radio_ssd["variable"] = self.technique_selection
        radio_ssd["justify"] = "left"
        radio_ssd["text"] = ui_constants.text_ssd_technique
        radio_ssd["command"] = self.select_technique
        radio_ssd.place(x=740, y=160, width=50, height=30)
        Hovertip(radio_ssd, ui_constants.text_description_ssd)

        radio_sod = tk.Radiobutton(self.root)
        radio_sod["value"] = 1
        radio_sod["variable"] = self.technique_selection
        radio_sod["justify"] = "left"
        radio_sod["text"] = ui_constants.text_sod_technique
        radio_sod["command"] = self.select_technique
        radio_sod.place(x=740, y=180, width=50, height=30)
        Hovertip(radio_sod, ui_constants.text_description_sod)

        radio_csd = tk.Radiobutton(self.root)
        radio_csd["value"] = 2
        radio_csd["variable"] = self.technique_selection
        radio_csd["justify"] = "left"
        radio_csd["text"] = ui_constants.text_csd_technique
        radio_csd["command"] = self.select_technique
        radio_csd.place(x=740, y=200, width=50, height=30)
        Hovertip(radio_csd, ui_constants.text_description_csd)

        radio_cod = tk.Radiobutton(self.root)
        radio_cod["value"] = 3
        radio_cod["variable"] = self.technique_selection
        radio_cod["justify"] = "left"
        radio_cod["text"] = ui_constants.text_cod_technique
        radio_cod["command"] = self.select_technique
        radio_cod.place(x=740, y=220, width=50, height=30)
        Hovertip(radio_cod, ui_constants.text_description_cod)

        self.button_play_active_learning = tk.Button(self.root)
        self.button_play_active_learning["bg"] = ui_constants.color_bg_button
        self.button_play_active_learning["fg"] = ui_constants.color_fg_button
        self.button_play_active_learning["text"] = ui_constants.text_play_active_learning
        self.button_play_active_learning["command"] = self.play_active_learning
        self.button_play_active_learning.place(x=350, y=320, width=180, height=30)

        self.output_area = tk.Text(self.root, state="disabled")
        self.output_area["fg"] = "#333333"
        self.output_area.place(x=50, y=370, width=800, height=200)

    def select_dataset_folder(self):
        self.base_folder = askdirectory()

    def set_reproducibility(self):
        self.reproducibility = not self.reproducibility

    def set_use_features(self):
        self.use_features = not self.use_features

    def set_resume(self):
        self.resume = not self.resume

    def select_technique(self):
        selection = self.technique_selection.get()
        if selection == 0:
            self.technique = TechniqueType.SCORE_SINGLE_DISTANCE

        elif selection == 1:
            self.technique = TechniqueType.SCORE_OTHER_DISTANCE

        elif selection == 2:
            self.technique = TechniqueType.CLASS_SINGLE_DISTANCE

        elif selection == 3:
            self.technique = TechniqueType.CLASS_OTHER_DISTANCE

        elif selection == 4:
            self.technique = TechniqueType.RANDOM

        elif selection == 5:
            self.technique = TechniqueType.LEAST_CONFIDENCE

    def play_active_learning(self):
        try:
            base_folder = self.base_folder
            samples_to_select = int(self.entry_quantity_samples_to_select.get())
            limit_samples = int(self.entry_limit_samples.get())
            resume = parse_bool(self.resume)
            reproducibility = parse_bool(self.reproducibility)
            use_features = parse_bool(self.use_features)
            training_epochs = int(self.entry_training_epochs.get())
            active_epochs = int(self.entry_active_epochs.get())
            technique = self.technique

        except:
            messagebox.showinfo(title=ui_constants.text_oops, message=ui_constants.text_all_fields_numbers)
            return

        if base_folder is None or base_folder == "":
            messagebox.showinfo(title=ui_constants.text_oops, message="{} '{}'!".format(ui_constants.text_you_should_put, ui_constants.text_dataset_folder))
            return

        elif samples_to_select is None or samples_to_select == "":
            messagebox.showinfo(title=ui_constants.text_oops, message="{} '{}'!".format(ui_constants.text_you_should_put, ui_constants.text_quantity_samples_to_select))
            return

        elif limit_samples is None or limit_samples == "":
            messagebox.showinfo(title=ui_constants.text_oops, message="{} '{}'!".format(ui_constants.text_you_should_put, ui_constants.text_limit_samples))
            return

        elif training_epochs is None or training_epochs == "":
            messagebox.showinfo(title=ui_constants.text_oops, message="{} '{}'!".format(ui_constants.text_you_should_put, ui_constants.text_training_epochs))
            return

        elif active_epochs is None or active_epochs == "":
            messagebox.showinfo(title=ui_constants.text_oops, message="{} '{}'!".format(ui_constants.text_you_should_put, ui_constants.text_active_epochs))
            return

        self.button_play_active_learning["command"] = self.show_alert_working
        thread = Thread(target=start_exploiting_gradient, args=(samples_to_select, limit_samples, resume, reproducibility, use_features, training_epochs, active_epochs, technique, base_folder, self, self.completed_task))
        thread.start()

    def completed_task(self, technique, elapsed_time, loss, accuracy):
        self.print_message("Completed, below the results:\nUsed technique: {}\nActive Learning training time: {}\nLoss after first training: {}\nLoss after exploiting gradient: {}\nAccuracy after first training: {}\nAccuracy after exploiting gradient: {}\n".format(technique, elapsed_time, loss[0], loss[1], accuracy[0], accuracy[1]))
        self.button_play_active_learning["command"] = self.play_active_learning
        messagebox.showinfo(title=ui_constants.text_oops, message=ui_constants.text_completed)

    def annotate(self, sample_to_annotate):
        # setting variables
        clicked = IntVar(0)
        self.class_selection = IntVar(0)
        self.selection = 0
        # setting UI
        appended_root = tk.Toplevel(self.root)
        # setting title
        appended_root.title(ui_constants.text_annotate)
        # setting layout
        width = 700
        height = 700
        screenwidth = appended_root.winfo_screenwidth()
        screenheight = appended_root.winfo_screenheight()
        align_string = '%dx%d+%d+%d' % (width, height, (screenwidth - width) / 2, (screenheight - height) / 2)
        appended_root.geometry(align_string)
        appended_root.resizable(width=False, height=False)

        top_image_render = ImageTk.PhotoImage(PIL.Image.open(sample_to_annotate))
        image_to_annotate=tk.Label(appended_root, image=top_image_render)
        image_to_annotate.image = top_image_render
        image_to_annotate.place(x=100, y=60, width=500, height=500)

        radio_contains = tk.Radiobutton(appended_root)
        radio_contains["value"] = 0
        radio_contains["variable"] = self.class_selection
        radio_contains["justify"] = "left"
        radio_contains["text"] = ui_constants.text_contains
        radio_contains["command"] = self.select_class
        radio_contains.place(x=250, y=600, width=100, height=30)

        radio_not_contains = tk.Radiobutton(appended_root)
        radio_not_contains["value"] = 1
        radio_not_contains["variable"] = self.class_selection
        radio_not_contains["justify"] = "left"
        radio_not_contains["text"] = ui_constants.text_not_contains
        radio_not_contains["command"] = self.select_class
        radio_not_contains.place(x=350, y=600, width=100, height=30)

        button_elaborate = tk.Button(appended_root)
        button_elaborate["bg"] = ui_constants.color_bg_button
        button_elaborate["fg"] = ui_constants.color_fg_button
        button_elaborate["justify"] = "center"
        button_elaborate["text"] = ui_constants.text_annotate
        button_elaborate["relief"] = "flat"
        button_elaborate.place(x=250, y=650, width=200, height=30)
        button_elaborate["command"] = lambda: clicked.set(1)
        button_elaborate.wait_variable(clicked)

        appended_root.destroy()
        return numpy.array([0, 1]) if self.selection == 0 else numpy.array([1, 0])

    def select_class(self):
        self.selection = self.class_selection.get()

    def show_alert_working(self):
        messagebox.showinfo(title=ui_constants.text_oops, message=ui_constants.text_process_running)

    def print_message(self, message):
        if self.printing_progress:
            self.output_area.configure(state="normal")
            self.output_area.insert(END, "\n")
            self.output_area.configure(state="disabled")
            self.printing_progress = False

        self.output_area.configure(state="normal")
        self.output_area.insert(END, "{}\n".format(message))
        self.output_area.configure(state="disabled")

    def print_progress_bar(self, message):
        self.printing_progress = True
        previous_text = self.output_area.get("1.0", "end - 1 lines")
        self.output_area.configure(state="normal")
        self.output_area.delete(1.0, "end")
        self.output_area.insert(END, "{}{}".format(previous_text, message))
        self.output_area.configure(state="disabled")
