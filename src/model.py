import numpy
import torch
import random
import warnings

from sklearn.ensemble import GradientBoostingRegressor, RandomForestClassifier
from exploiting_gradient import exploit_gradient
from technique_type import TechniqueType
from dataset.selector_dataset import SelectorDataset
from dataset.real_human.melanoma_real_human_dataset import MelanomaRealHumanDataset
from vae.vae import VAE
from neural_network.convolutional_melanoma_neural_network import ConvolutionalMelanomaNeuralNetwork
from support import cprint, Color

try:
    from data.libs.neural_network import NeuralNetwork
    _neural_network_loaded = True

except:
    _neural_network_loaded = False

try:
    from data.libs.features_extractor import FeaturesExtractor
    _features_extractor_loaded = True

except:
    _features_extractor_loaded = False

try:
    from data.libs.concrete_human_dataset import ConcreteHumanDataset
    _concrete_human_dataset_loaded = True

except:
    _concrete_human_dataset_loaded = False

warnings.filterwarnings("ignore", category=UserWarning)


def start_exploiting_gradient(samples_to_select, limit_samples, resume, reproducibility, use_features, training_epochs, active_epochs, technique, base_folder, delegate, callback):
    # setting reproducibility
    if reproducibility:
        torch.manual_seed(0)
        numpy.random.seed(0)
        random.seed(0)

    # setting configuration
    device = "cuda" if torch.cuda.is_available() else "cpu"
    input_size = 512 * 512 * 3
    cprint("Running on {}...".format(device), Color.BLUE)

    # setting technique
    if technique == TechniqueType.SCORE_SINGLE_DISTANCE or technique == TechniqueType.SCORE_OTHER_DISTANCE:
        model = GradientBoostingRegressor(loss="lad", n_estimators=200)

    else:
        model = RandomForestClassifier(max_depth=5)

    # setting use features
    if use_features:
        global _features_extractor_loaded
        if _features_extractor_loaded:
            features_extractor = FeaturesExtractor(device)

        else:
            features_extractor = VAE(device, "VAE", 512, 3, 7, 10)

    else:
        features_extractor = None

    # setting neural network
    global _neural_network_loaded
    if _neural_network_loaded:
        neural_network = NeuralNetwork(device)

    else:
        neural_network = ConvolutionalMelanomaNeuralNetwork(device)
        neural_network.criterion = torch.nn.MSELoss()
        neural_network.optimizer = torch.optim.Adam(neural_network.parameters(), lr=1e-4, weight_decay=5e-4)

    # defining nn's dataset with simulated annotator
    global _concrete_human_dataset_loaded
    if _concrete_human_dataset_loaded:
        dataset_real_human = ConcreteHumanDataset(delegate)

    else:
        dataset_real_human = MelanomaRealHumanDataset(base_folder, delegate)

    # defining selector's dataset to build
    classed = (technique == TechniqueType.CLASS_SINGLE_DISTANCE or technique == TechniqueType.CLASS_OTHER_DISTANCE)
    dataset_selector = SelectorDataset(input_size, classed)

    # loading training
    start_loss, start_accuracy, end_loss, end_accuracy, elapsed_time = exploit_gradient(technique, samples_to_select, training_epochs, active_epochs, model, neural_network, dataset_real_human, dataset_selector, resume, limit_samples, features_extractor)
    neural_network.save("./data/networks/cnn_{}_.net".format(technique))

    if callback is not None:
        callback(technique, elapsed_time, (start_loss, end_loss), (start_accuracy, end_accuracy))

    else:
        return technique, elapsed_time, (start_loss, end_loss), (start_accuracy, end_accuracy)
