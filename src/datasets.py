import numpy
import torch

from torch.utils.data import Dataset, DataLoader


# nn's dataset
class FakeHumanDataset(Dataset):

    def __init__(self, x, y, batch_size, total_labeled_samples_size=0, total_unlabeled_samples_size=0, input_size=0, output_size=0, metric_size = 0):
        self.batch_size = batch_size
        if x is None or y is None:
            self.x = torch.randn(total_labeled_samples_size, input_size)
            self.y = torch.randn(total_labeled_samples_size, output_size)
            # human
            x_unlabeled = torch.randn(total_unlabeled_samples_size, input_size)
            y_unlabeled = torch.randn(total_unlabeled_samples_size, output_size)
            iterator = zip(x_unlabeled, y_unlabeled)
            self.unlabeled_elements = dict(iterator)
            # for metrics
            self.x_metric = torch.randn(metric_size, input_size)
            self.y_metric = torch.randn(metric_size, output_size)

        else:
            self.x = x
            self.y = y

    def __getitem__(self, index):
        return {"x": self.x[index], "y": self.y[index]}

    def __len__(self):
        if type(self.x) is list:
            return len(self.x)

        else:
            return self.x.shape[0]

    def get_dataloader(self):
        return DataLoader(self, batch_size=self.batch_size)

    def get_metrics_dataloader(self):
        return DataLoader(FakeHumanDataset(self.x_metric, self.y_metric, self.batch_size), batch_size=self.batch_size)

    def get_random_labeled_samples(self, quantity):
        x_popped = []
        y_popped = []
        taken = 0
        for key in self.unlabeled_elements.keys():
            x_popped.append(key)
            y_popped.append(self.unlabeled_elements[key])
            taken += 1
            if taken >= quantity:
                break

        for key in x_popped:
            self.unlabeled_elements.pop(key)

        return x_popped, y_popped

    def get_all_unlabeled_samples(self):
        return list(self.unlabeled_elements.keys())

    def annotate(self, x_to_label):
        x_popped = []
        y_popped = []
        for key in x_to_label:
            x_popped.append(key)
            y_popped.append(self.unlabeled_elements.pop(key))

        return x_popped, y_popped


# selector's dataset
class SamplesDataset:

    def __init__(self):
        self.xs = []
        self.ys = []

    def add_sample(self, x, y):
        self.xs.append(x)
        self.ys.append(y)

    def get_train_dataset(self):
        return numpy.array(self.xs), numpy.array(self.ys)

    def __getitem__(self, index):
        return {"x": self.x[index], "y": self.y[index]}

    def __len__(self):
        return self.xs.shape[0]
