import numpy
import torch
import random
import warnings

from sklearn.ensemble import GradientBoostingRegressor, RandomForestClassifier
from exploiting_gradient import exploit_gradient
from technique_type import TechniqueType
from dataset.selector_dataset import SelectorDataset
from dataset.real_human.melanoma_real_human_dataset import MelanomaRealHumanDataset
from vae.vae import VAE
from neural_network.convolutional_melanoma_neural_network import ConvolutionalMelanomaNeuralNetwork

warnings.filterwarnings("ignore", category=UserWarning)


def start_exploiting_gradient(samples_to_select, limit_samples, resume, reproducibility, use_features, training_epochs, active_epochs, technique, base_folder, delegate, callback):
    # setting reproducibility
    if reproducibility:
        torch.manual_seed(0)
        numpy.random.seed(0)
        random.seed(0)

    # setting configuration
    device = "cuda" if torch.cuda.is_available() else "cpu"
    input_size = 512 * 512 * 3

    # setting technique
    if technique == TechniqueType.SCORE_SINGLE_DISTANCE or technique == TechniqueType.SCORE_OTHER_DISTANCE:
        model = GradientBoostingRegressor(loss="lad", n_estimators=200)

    else:
        model = RandomForestClassifier(max_depth=5)

    # setting use features
    if use_features:
        features_extractor = VAE(device, "VAE melanoma", 512, 3, 7, 10)

    else:
        features_extractor = None

    # setting neural network
    neural_network = ConvolutionalMelanomaNeuralNetwork(device)
    neural_network.criterion = torch.nn.MSELoss()
    neural_network.optimizer = torch.optim.Adam(neural_network.parameters(), lr=1e-4, weight_decay=5e-4)

    # defining nn's dataset with simulated annotator
    dataset_real_human = MelanomaRealHumanDataset(base_folder, delegate)

    # defining selector's dataset to build
    classed = technique == TechniqueType.CLASS_SINGLE_DISTANCE or technique == TechniqueType.CLASS_OTHER_DISTANCE
    dataset_selector = SelectorDataset(input_size, classed)

    # loading training
    start_loss, start_accuracy, end_loss, end_accuracy, elapsed_time = exploit_gradient(technique, samples_to_select, training_epochs, active_epochs, model, neural_network, dataset_real_human, dataset_selector, resume, limit_samples, features_extractor)
    neural_network.save("./data/networks/cnn_{}_.net".format(technique))

    if callback is not None:
        callback(technique, elapsed_time, (start_loss, end_loss), (start_accuracy, end_accuracy))

    else:
        return technique, elapsed_time, (start_loss, end_loss), (start_accuracy, end_accuracy)
